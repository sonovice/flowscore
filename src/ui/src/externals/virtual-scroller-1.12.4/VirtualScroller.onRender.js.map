{"version":3,"file":"VirtualScroller.onRender.js","names":["log","warn","reportError","isDebug","getStateSnapshot","shallowEqual","LAYOUT_REASON","setTbodyPadding","_onRender","newState","prevState","waitingForRender","onStateChange","tbody","getItemsContainerElement","beforeItemsHeight","afterItemsHeight","mostRecentSetStateValue","resetStateUpdateFlags","call","nonMeasuredItemsHaveBeenRendered","itemHeightHasChanged","widthHasChanged","layoutUpdateReason","ITEM_HEIGHT_CHANGED","NON_MEASURED_ITEMS_HAVE_BEEN_MEASURED","VIEWPORT_WIDTH_CHANGED","itemHeights","reset","verticalSpacing","undefined","previousItems","items","newItems","itemsDiff","getItemsDiff","prependedItemsCount","onPrepend","onNewItemsRendered","ITEMS_CHANGED","stateUpdate","firstShownItemIndex","lastShownItemIndex","verticalSpacingStateUpdate","measureItemHeightsAndSpacing","cleanedUpBeforeResize","beforeResize","cleanUpBeforeResizeItemHeights","scrollBy","scroll","scrollByY","_isActive","_afterRenderStateUpdateThatWasStopped","updateStateRightAfterRender","reason","updateState","newLayout","appendedItemsCount","getState","itemStates","itemHeightsThatChangedWhileNewItemsWereBeingRendered","Object","keys","i","Number","itemStatesThatChangedWhileNewItemsWereBeingRendered","previouslyCalculatedLayout","listHeightMeasurement","hasSnapshot","listBottomOffsetChange","getListBottomOffsetChange","shownItemsHeight","_useTimeoutInRenderLoop","cancelLayoutTimer","scheduleLayoutTimer","onUpdateShownItemIndexes","Boolean","firstNonMeasuredItemIndex","newItemsWillBeRendered","updateLayoutAfterRenderBecauseItemHeightChanged"],"sources":["../source/VirtualScroller.onRender.js"],"sourcesContent":["import log, { warn, reportError, isDebug } from './utility/debug.js'\nimport getStateSnapshot from './utility/getStateSnapshot.js'\nimport shallowEqual from './utility/shallowEqual.js'\nimport { LAYOUT_REASON } from './Layout.js'\nimport { setTbodyPadding } from './DOM/tbody.js'\n\nexport default function() {\n\t/**\n\t * Should be called right after updates to `state` have been rendered.\n\t * @param  {object} newState\n\t * @param  {object} [prevState]\n\t */\n\tthis._onRender = (newState, prevState) => {\n\t\tthis.waitingForRender = false\n\n\t\tlog('~ Rendered ~')\n\t\tif (isDebug()) {\n\t\t\tlog('State', getStateSnapshot(newState))\n\t\t}\n\n\t\tif (this.onStateChange) {\n\t\t\tif (!shallowEqual(newState, prevState)) {\n\t\t\t\tthis.onStateChange(newState)\n\t\t\t}\n\t\t}\n\n\t\t// Update `<tbody/>` `padding`.\n\t\t// (`<tbody/>` is different in a way that it can't have `margin`, only `padding`).\n\t\t// https://gitlab.com/catamphetamine/virtual-scroller/-/issues/1\n\t\tif (this.tbody) {\n\t\t\tsetTbodyPadding(\n\t\t\t\tthis.getItemsContainerElement(),\n\t\t\t\tnewState.beforeItemsHeight,\n\t\t\t\tnewState.afterItemsHeight\n\t\t\t)\n\t\t}\n\n\t\t// `this.mostRecentlySetState` checks that state management behavior is correct:\n\t\t// that in situations when there're multiple new states waiting to be set,\n\t\t// only the latest one gets applied.\n\t\t// It keeps the code simpler and prevents possible race condition bugs.\n\t\t// For example, `VirtualScroller` keeps track of its latest requested\n\t\t// state update in different instance variable flags which assume that\n\t\t// only that latest requested state update gets actually applied.\n\t\t//\n\t\t// This check should also be performed for the initial render in order to\n\t\t// guarantee that no potentially incorrect state update goes unnoticed.\n\t\t// Incorrect state updates could happen when `VirtualScroller` state\n\t\t// is managed externally by passing `getState()`/`updateState()` options.\n\t\t//\n\t\t// Perform the check only when `this.mostRecentSetStateValue` is defined.\n\t\t// `this.mostRecentSetStateValue` is normally gonna be `undefined` at the initial render\n\t\t// because the initial state is not set by calling `this.updateState()`.\n\t\t// At the same time, it is possible that the initial render is delayed\n\t\t// for whatever reason, and `this.updateState()` gets called before the initial render,\n\t\t// so `this.mostRecentSetStateValue` could also be defined at the initial render,\n\t\t// in which case the check should be performed.\n\t\t//\n\t\tif (this.mostRecentSetStateValue) {\n\t\t\t// \"Shallow equality\" is used here instead of \"strict equality\"\n\t\t\t// because a developer might choose to supply an `updateState()` function\n\t\t\t// rather than a `setState()` function, in which case the `updateState()` function\n\t\t\t// would construct its own state object.\n\t\t\tif (!shallowEqual(newState, this.mostRecentSetStateValue)) {\n\t\t\t\twarn('The most recent state that was set', getStateSnapshot(this.mostRecentSetStateValue))\n\t\t\t\treportError('`VirtualScroller` has been rendered with a `state` that is not equal to the most recently set one')\n\t\t\t}\n\t\t}\n\n\t\t// `this.resetStateUpdateFlags()` must be called before calling\n\t\t// `this.measureItemHeightsAndSpacing()`.\n\t\tconst {\n\t\t\tnonMeasuredItemsHaveBeenRendered,\n\t\t\titemHeightHasChanged,\n\t\t\twidthHasChanged\n\t\t} = resetStateUpdateFlags.call(this)\n\n\t\tlet layoutUpdateReason\n\n\t\tif (itemHeightHasChanged) {\n\t\t\tlayoutUpdateReason = LAYOUT_REASON.ITEM_HEIGHT_CHANGED\n\t\t}\n\n\t\tif (!prevState) {\n\t\t\tif (!layoutUpdateReason) {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\t// If the `VirtualScroller`, while calculating layout parameters, encounters\n\t\t// a not-shown item with a non-measured height, it calls `updateState()` just to\n\t\t// render that item first, and then, after the list has been re-rendered, it measures\n\t\t// the item's height and then proceeds with calculating the correct layout parameters.\n\t\tif (nonMeasuredItemsHaveBeenRendered) {\n\t\t\tlayoutUpdateReason = LAYOUT_REASON.NON_MEASURED_ITEMS_HAVE_BEEN_MEASURED\n\t\t}\n\n\t\t// If scrollable container width has changed, and it has been re-rendered,\n\t\t// then it's time to measure the new item heights and then perform a re-layout\n\t\t// with the correctly calculated layout parameters.\n\t\t//\n\t\t// A re-layout is required because the layout parameters calculated on resize\n\t\t// are approximate ones, and the exact item heights aren't known at that point.\n\t\t// So on resize, it calls `updateState()` just to re-render the `VirtualScroller`.\n\t\t// After it has been re-rendered, it will measure item heights and then calculate\n\t\t// correct layout parameters.\n\t\t//\n\t\tif (widthHasChanged) {\n\t\t\tlayoutUpdateReason = LAYOUT_REASON.VIEWPORT_WIDTH_CHANGED\n\n\t\t\t// Reset measured item heights on viewport width change.\n\t\t\tthis.itemHeights.reset()\n\n\t\t\t// Reset `verticalSpacing` (will be re-measured).\n\t\t\tthis.verticalSpacing = undefined\n\t\t}\n\n\t\tif (prevState) {\n\t\t\tconst { items: previousItems } = prevState\n\t\t\tconst { items: newItems } = newState\n\t\t\t// Even if `this.newItemsWillBeRendered` flag is `true`,\n\t\t\t// `newItems` could still be equal to `previousItems`.\n\t\t\t// For example, when `updateState()` calls don't update `state` immediately\n\t\t\t// and a developer first calls `setItems(newItems)` and then calls `setItems(oldItems)`:\n\t\t\t// in that case, `this.newItemsWillBeRendered` flag will be `true` but the actual `items`\n\t\t\t// in state wouldn't have changed due to the first `updateState()` call being overwritten\n\t\t\t// by the second `updateState()` call (that's called \"batching state updates\" in React).\n\t\t\tif (newItems !== previousItems) {\n\t\t\t\tconst itemsDiff = this.getItemsDiff(previousItems, newItems)\n\t\t\t\tif (itemsDiff) {\n\t\t\t\t\t// The call to `.onPrepend()` must precede the call to `.measureItemHeights()`\n\t\t\t\t\t// which is called in `.onRender()`.\n\t\t\t\t\t// `this.itemHeights.onPrepend()` updates `firstMeasuredItemIndex`\n\t\t\t\t\t// and `lastMeasuredItemIndex` of `this.itemHeights`.\n\t\t\t\t\tconst { prependedItemsCount } = itemsDiff\n\t\t\t\t\tthis.itemHeights.onPrepend(prependedItemsCount)\n\t\t\t\t} else {\n\t\t\t\t\tthis.itemHeights.reset()\n\t\t\t\t}\n\n\t\t\t\tif (!widthHasChanged) {\n\t\t\t\t\t// The call to `this.onNewItemsRendered()` must precede the call to\n\t\t\t\t\t// `.measureItemHeights()` which is called in `.onRender()` because\n\t\t\t\t\t// `this.onNewItemsRendered()` updates `firstMeasuredItemIndex` and\n\t\t\t\t\t// `lastMeasuredItemIndex` of `this.itemHeights` in case of a prepend.\n\t\t\t\t\t//\n\t\t\t\t\t// If after prepending items the scroll position\n\t\t\t\t\t// should be \"restored\" so that there's no \"jump\" of content\n\t\t\t\t\t// then it means that all previous items have just been rendered\n\t\t\t\t\t// in a single pass, and there's no need to update layout again.\n\t\t\t\t\t//\n\t\t\t\t\tif (onNewItemsRendered.call(this, itemsDiff, newState) !== 'SEAMLESS_PREPEND') {\n\t\t\t\t\t\tlayoutUpdateReason = LAYOUT_REASON.ITEMS_CHANGED\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet stateUpdate\n\n\t\t// Re-measure item heights.\n\t\t// Also, measure vertical spacing (if not measured) and fix `<table/>` padding.\n\t\t//\n\t\t// This block should go after `if (newItems !== previousItems) {}`\n\t\t// because `this.itemHeights` can get `.reset()` there, which would\n\t\t// discard all the measurements done here, and having currently shown\n\t\t// item height measurements is required.\n\t\t//\n\t\tif (\n\t\t\t(prevState && (\n\t\t\t\tnewState.firstShownItemIndex !== prevState.firstShownItemIndex ||\n\t\t\t\tnewState.lastShownItemIndex !== prevState.lastShownItemIndex ||\n\t\t\t\tnewState.items !== prevState.items\n\t\t\t)) ||\n\t\t\twidthHasChanged\n\t\t) {\n\t\t\tconst verticalSpacingStateUpdate = this.measureItemHeightsAndSpacing()\n\t\t\tif (verticalSpacingStateUpdate) {\n\t\t\t\tstateUpdate = {\n\t\t\t\t\t...stateUpdate,\n\t\t\t\t\t...verticalSpacingStateUpdate\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Clean up \"before resize\" item heights and adjust the scroll position accordingly.\n\t\t// Calling `this.beforeResize.cleanUpBeforeResizeItemHeights()` might trigger\n\t\t// a `this.updateState()` call but that wouldn't matter because `beforeResize`\n\t\t// properties have already been modified directly in `state` (a hacky technique)\n\t\tconst cleanedUpBeforeResize = this.beforeResize.cleanUpBeforeResizeItemHeights()\n\t\tif (cleanedUpBeforeResize !== undefined) {\n\t\t\tconst { scrollBy, beforeResize } = cleanedUpBeforeResize\n\t\t\tlog('Correct scroll position by', scrollBy)\n\t\t\tthis.scroll.scrollByY(scrollBy)\n\t\t\tstateUpdate = {\n\t\t\t\t...stateUpdate,\n\t\t\t\tbeforeResize\n\t\t\t}\n\t\t}\n\n\t\tif (!this._isActive) {\n\t\t\tthis._afterRenderStateUpdateThatWasStopped = stateUpdate\n\t\t\treturn\n\t\t}\n\n\t\tif (layoutUpdateReason) {\n\t\t\tupdateStateRightAfterRender.call(this, {\n\t\t\t\tstateUpdate,\n\t\t\t\treason: layoutUpdateReason\n\t\t\t})\n\t\t} else if (stateUpdate) {\n\t\t\tthis.updateState(stateUpdate)\n\t\t} else {\n\t\t\tlog('~ Finished Layout ~')\n\t\t}\n\t}\n\n\t// After a new set of items has been rendered:\n\t//\n\t// * Restores scroll position when using `preserveScrollPositionOnPrependItems`\n\t//   and items have been prepended.\n\t//\n\t// * Applies any \"pending\" `itemHeights` updates â€” those ones that happened\n\t//   while an asynchronous `updateState()` call in `setItems()` was pending.\n\t//\n\t// * Either creates or resets the snapshot of the current layout.\n\t//\n\t//   The current layout snapshot could be stored as a \"previously calculated layout\" variable\n\t//   so that it could theoretically be used when calculating new layout incrementally\n\t//   rather than from scratch, which would be an optimization.\n\t//\n\t//   The \"previously calculated layout\" feature is not currently used.\n\t//\n\tfunction onNewItemsRendered(itemsDiff, newLayout) {\n\t\t// If it's an \"incremental\" update.\n\t\tif (itemsDiff) {\n\t\t\tconst {\n\t\t\t\tprependedItemsCount,\n\t\t\t\tappendedItemsCount\n\t\t\t} = itemsDiff\n\n\t\t\tconst {\n\t\t\t\titemHeights,\n\t\t\t\titemStates\n\t\t\t} = this.getState()\n\n\t\t\t// See if any items' heights changed while new items were being rendered.\n\t\t\tif (this.itemHeightsThatChangedWhileNewItemsWereBeingRendered) {\n\t\t\t\tfor (const i of Object.keys(this.itemHeightsThatChangedWhileNewItemsWereBeingRendered)) {\n\t\t\t\t\titemHeights[prependedItemsCount + Number(i)] = this.itemHeightsThatChangedWhileNewItemsWereBeingRendered[i]\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// See if any items' states changed while new items were being rendered.\n\t\t\tif (this.itemStatesThatChangedWhileNewItemsWereBeingRendered) {\n\t\t\t\tfor (const i of Object.keys(this.itemStatesThatChangedWhileNewItemsWereBeingRendered)) {\n\t\t\t\t\titemStates[prependedItemsCount + Number(i)] = this.itemStatesThatChangedWhileNewItemsWereBeingRendered[i]\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (prependedItemsCount === 0) {\n\t\t\t\t// Adjust `this.previouslyCalculatedLayout`.\n\t\t\t\tif (this.previouslyCalculatedLayout) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tthis.previouslyCalculatedLayout.firstShownItemIndex === newLayout.firstShownItemIndex &&\n\t\t\t\t\t\tthis.previouslyCalculatedLayout.lastShownItemIndex === newLayout.lastShownItemIndex\n\t\t\t\t\t) {\n\t\t\t\t\t\t// `this.previouslyCalculatedLayout` stays the same.\n\t\t\t\t\t\t// `firstShownItemIndex` / `lastShownItemIndex` didn't get changed in `setItems()`,\n\t\t\t\t\t\t// so `beforeItemsHeight` and `shownItemsHeight` also stayed the same.\n\t\t\t\t\t} else {\n\t\t\t\t\t\twarn('Unexpected (non-matching) \"firstShownItemIndex\" or \"lastShownItemIndex\" encountered in \"onRender()\" after appending items')\n\t\t\t\t\t\twarn('Previously calculated layout', this.previouslyCalculatedLayout)\n\t\t\t\t\t\twarn('New layout', newLayout)\n\t\t\t\t\t\tthis.previouslyCalculatedLayout = undefined\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn 'SEAMLESS_APPEND'\n\t\t\t} else {\n\t\t\t\tif (this.listHeightMeasurement.hasSnapshot()) {\n\t\t\t\t\tif (newLayout.firstShownItemIndex === 0) {\n\t\t\t\t\t\t// Restore (adjust) scroll position.\n\t\t\t\t\t\tlog('~ Restore Scroll Position ~')\n\t\t\t\t\t\tconst listBottomOffsetChange = this.listHeightMeasurement.getListBottomOffsetChange({\n\t\t\t\t\t\t\tbeforeItemsHeight: newLayout.beforeItemsHeight\n\t\t\t\t\t\t})\n\t\t\t\t\t\tthis.listHeightMeasurement.reset()\n\t\t\t\t\t\tif (listBottomOffsetChange) {\n\t\t\t\t\t\t\tlog('Scroll down by', listBottomOffsetChange)\n\t\t\t\t\t\t\tthis.scroll.scrollByY(listBottomOffsetChange)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlog('Scroll position hasn\\'t changed')\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Create new `this.previouslyCalculatedLayout`.\n\t\t\t\t\t\tif (this.previouslyCalculatedLayout) {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tthis.previouslyCalculatedLayout.firstShownItemIndex === 0 &&\n\t\t\t\t\t\t\t\tthis.previouslyCalculatedLayout.lastShownItemIndex === newLayout.lastShownItemIndex - prependedItemsCount\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tthis.previouslyCalculatedLayout = {\n\t\t\t\t\t\t\t\t\tbeforeItemsHeight: 0,\n\t\t\t\t\t\t\t\t\tshownItemsHeight: this.previouslyCalculatedLayout.shownItemsHeight + listBottomOffsetChange,\n\t\t\t\t\t\t\t\t\tfirstShownItemIndex: 0,\n\t\t\t\t\t\t\t\t\tlastShownItemIndex: newLayout.lastShownItemIndex\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\twarn('Unexpected (non-matching) \"firstShownItemIndex\" or \"lastShownItemIndex\" encountered in \"onRender()\" after prepending items')\n\t\t\t\t\t\t\t\twarn('Previously calculated layout', this.previouslyCalculatedLayout)\n\t\t\t\t\t\t\t\twarn('New layout', newLayout)\n\t\t\t\t\t\t\t\tthis.previouslyCalculatedLayout = undefined\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn 'SEAMLESS_PREPEND'\n\t\t\t\t\t} else {\n\t\t\t\t\t\twarn(`Unexpected \"firstShownItemIndex\" ${newLayout.firstShownItemIndex} encountered in \"onRender()\" after prepending items. Expected 0.`)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Reset `this.previouslyCalculatedLayout` in any case other than\n\t\t// SEAMLESS_PREPEND or SEAMLESS_APPEND.\n\t\tthis.previouslyCalculatedLayout = undefined\n\t}\n\n\tfunction updateStateRightAfterRender({\n\t\treason,\n\t\tstateUpdate\n\t}) {\n\t\t// In React, `setTimeout()` is used to prevent a React error:\n\t\t// \"Maximum update depth exceeded.\n\t\t//  This can happen when a component repeatedly calls\n\t\t//  `.updateState()` inside `componentWillUpdate()` or `componentDidUpdate()`.\n\t\t//  React limits the number of nested updates to prevent infinite loops.\"\n\t\tif (this._useTimeoutInRenderLoop) {\n\t\t\t// Cancel a previously scheduled re-layout.\n\t\t\tstateUpdate = this.cancelLayoutTimer({ stateUpdate })\n\t\t\t// Schedule a new re-layout.\n\t\t\tthis.scheduleLayoutTimer({\n\t\t\t\treason,\n\t\t\t\tstateUpdate\n\t\t\t})\n\t\t} else {\n\t\t\tthis.onUpdateShownItemIndexes({\n\t\t\t\treason,\n\t\t\t\tstateUpdate\n\t\t\t})\n\t\t}\n\t}\n\n\tfunction resetStateUpdateFlags() {\n\t\t// Read and reset `this.widthHasChanged` flag.\n\t\t//\n\t\t// If `this.widthHasChanged` flag was reset after calling\n\t\t// `this.measureWidthHeightsAndSpacingAndUpdateTablePadding()`\n\t\t// then there would be a bug because\n\t\t// `this.measureWidthHeightsAndSpacingAndUpdateTablePadding()`\n\t\t// calls `this.updateState({ verticalSpacing })` which calls\n\t\t// `this.onRender()` immediately, so `this.widthHasChanged`\n\t\t// flag wouldn't be reset by that time and would trigger things\n\t\t// like `this.itemHeights.reset()` a second time.\n\t\t//\n\t\t// So, instead read the value of `this.widthHasChanged` flag\n\t\t// and reset it right away to prevent any such potential bugs.\n\t\t//\n\t\tconst widthHasChanged = Boolean(this.widthHasChanged)\n\t\t//\n\t\t// Reset `this.widthHasChanged` flag.\n\t\tthis.widthHasChanged = undefined\n\n\t\t// Read `this.firstNonMeasuredItemIndex` flag.\n\t\tconst nonMeasuredItemsHaveBeenRendered = this.firstNonMeasuredItemIndex !== undefined\n\t\tif (nonMeasuredItemsHaveBeenRendered) {\n\t\t\tlog('Non-measured item index', this.firstNonMeasuredItemIndex)\n\t\t}\n\t\t// Reset `this.firstNonMeasuredItemIndex` flag.\n\t\tthis.firstNonMeasuredItemIndex = undefined\n\n\t\t// Reset `this.newItemsWillBeRendered` flag.\n\t\tthis.newItemsWillBeRendered = undefined\n\n\t\t// Reset `this.itemHeightsThatChangedWhileNewItemsWereBeingRendered`.\n\t\tthis.itemHeightsThatChangedWhileNewItemsWereBeingRendered = undefined\n\n\t\t// Reset `this.itemStatesThatChangedWhileNewItemsWereBeingRendered`.\n\t\tthis.itemStatesThatChangedWhileNewItemsWereBeingRendered = undefined\n\n\t\t// Reset `this.updateLayoutAfterRenderBecauseItemHeightChanged`.\n\t\tconst itemHeightHasChanged = this.updateLayoutAfterRenderBecauseItemHeightChanged\n\t\tthis.updateLayoutAfterRenderBecauseItemHeightChanged = undefined\n\n\t\treturn {\n\t\t\tnonMeasuredItemsHaveBeenRendered,\n\t\t\titemHeightHasChanged,\n\t\t\twidthHasChanged\n\t\t}\n\t}\n}"],"mappings":";;;;;;AAAA,OAAOA,GAAP,IAAcC,IAAd,EAAoBC,WAApB,EAAiCC,OAAjC,QAAgD,oBAAhD;AACA,OAAOC,gBAAP,MAA6B,+BAA7B;AACA,OAAOC,YAAP,MAAyB,2BAAzB;AACA,SAASC,aAAT,QAA8B,aAA9B;AACA,SAASC,eAAT,QAAgC,gBAAhC;AAEA,eAAe,YAAW;EAAA;;EACzB;AACD;AACA;AACA;AACA;EACC,KAAKC,SAAL,GAAiB,UAACC,QAAD,EAAWC,SAAX,EAAyB;IACzC,KAAI,CAACC,gBAAL,GAAwB,KAAxB;IAEAX,GAAG,CAAC,cAAD,CAAH;;IACA,IAAIG,OAAO,EAAX,EAAe;MACdH,GAAG,CAAC,OAAD,EAAUI,gBAAgB,CAACK,QAAD,CAA1B,CAAH;IACA;;IAED,IAAI,KAAI,CAACG,aAAT,EAAwB;MACvB,IAAI,CAACP,YAAY,CAACI,QAAD,EAAWC,SAAX,CAAjB,EAAwC;QACvC,KAAI,CAACE,aAAL,CAAmBH,QAAnB;MACA;IACD,CAZwC,CAczC;IACA;IACA;;;IACA,IAAI,KAAI,CAACI,KAAT,EAAgB;MACfN,eAAe,CACd,KAAI,CAACO,wBAAL,EADc,EAEdL,QAAQ,CAACM,iBAFK,EAGdN,QAAQ,CAACO,gBAHK,CAAf;IAKA,CAvBwC,CAyBzC;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;;IACA,IAAI,KAAI,CAACC,uBAAT,EAAkC;MACjC;MACA;MACA;MACA;MACA,IAAI,CAACZ,YAAY,CAACI,QAAD,EAAW,KAAI,CAACQ,uBAAhB,CAAjB,EAA2D;QAC1DhB,IAAI,CAAC,oCAAD,EAAuCG,gBAAgB,CAAC,KAAI,CAACa,uBAAN,CAAvD,CAAJ;QACAf,WAAW,CAAC,mGAAD,CAAX;MACA;IACD,CAvDwC,CAyDzC;IACA;;;IACA,4BAIIgB,qBAAqB,CAACC,IAAtB,CAA2B,KAA3B,CAJJ;IAAA,IACCC,gCADD,yBACCA,gCADD;IAAA,IAECC,oBAFD,yBAECA,oBAFD;IAAA,IAGCC,eAHD,yBAGCA,eAHD;;IAMA,IAAIC,kBAAJ;;IAEA,IAAIF,oBAAJ,EAA0B;MACzBE,kBAAkB,GAAGjB,aAAa,CAACkB,mBAAnC;IACA;;IAED,IAAI,CAACd,SAAL,EAAgB;MACf,IAAI,CAACa,kBAAL,EAAyB;QACxB;MACA;IACD,CA3EwC,CA6EzC;IACA;IACA;IACA;;;IACA,IAAIH,gCAAJ,EAAsC;MACrCG,kBAAkB,GAAGjB,aAAa,CAACmB,qCAAnC;IACA,CAnFwC,CAqFzC;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;;IACA,IAAIH,eAAJ,EAAqB;MACpBC,kBAAkB,GAAGjB,aAAa,CAACoB,sBAAnC,CADoB,CAGpB;;MACA,KAAI,CAACC,WAAL,CAAiBC,KAAjB,GAJoB,CAMpB;;;MACA,KAAI,CAACC,eAAL,GAAuBC,SAAvB;IACA;;IAED,IAAIpB,SAAJ,EAAe;MACd,IAAeqB,aAAf,GAAiCrB,SAAjC,CAAQsB,KAAR;MACA,IAAeC,QAAf,GAA4BxB,QAA5B,CAAQuB,KAAR,CAFc,CAGd;MACA;MACA;MACA;MACA;MACA;MACA;;MACA,IAAIC,QAAQ,KAAKF,aAAjB,EAAgC;QAC/B,IAAMG,SAAS,GAAG,KAAI,CAACC,YAAL,CAAkBJ,aAAlB,EAAiCE,QAAjC,CAAlB;;QACA,IAAIC,SAAJ,EAAe;UACd;UACA;UACA;UACA;UACA,IAAQE,mBAAR,GAAgCF,SAAhC,CAAQE,mBAAR;;UACA,KAAI,CAACT,WAAL,CAAiBU,SAAjB,CAA2BD,mBAA3B;QACA,CAPD,MAOO;UACN,KAAI,CAACT,WAAL,CAAiBC,KAAjB;QACA;;QAED,IAAI,CAACN,eAAL,EAAsB;UACrB;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA,IAAIgB,kBAAkB,CAACnB,IAAnB,CAAwB,KAAxB,EAA8Be,SAA9B,EAAyCzB,QAAzC,MAAuD,kBAA3D,EAA+E;YAC9Ec,kBAAkB,GAAGjB,aAAa,CAACiC,aAAnC;UACA;QACD;MACD;IACD;;IAED,IAAIC,WAAJ,CAlJyC,CAoJzC;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IACA,IACE9B,SAAS,KACTD,QAAQ,CAACgC,mBAAT,KAAiC/B,SAAS,CAAC+B,mBAA3C,IACAhC,QAAQ,CAACiC,kBAAT,KAAgChC,SAAS,CAACgC,kBAD1C,IAEAjC,QAAQ,CAACuB,KAAT,KAAmBtB,SAAS,CAACsB,KAHpB,CAAV,IAKAV,eAND,EAOE;MACD,IAAMqB,0BAA0B,GAAG,KAAI,CAACC,4BAAL,EAAnC;;MACA,IAAID,0BAAJ,EAAgC;QAC/BH,WAAW,mCACPA,WADO,GAEPG,0BAFO,CAAX;MAIA;IACD,CA3KwC,CA6KzC;IACA;IACA;IACA;;;IACA,IAAME,qBAAqB,GAAG,KAAI,CAACC,YAAL,CAAkBC,8BAAlB,EAA9B;;IACA,IAAIF,qBAAqB,KAAKf,SAA9B,EAAyC;MACxC,IAAQkB,QAAR,GAAmCH,qBAAnC,CAAQG,QAAR;MAAA,IAAkBF,YAAlB,GAAmCD,qBAAnC,CAAkBC,YAAlB;MACA9C,GAAG,CAAC,4BAAD,EAA+BgD,QAA/B,CAAH;;MACA,KAAI,CAACC,MAAL,CAAYC,SAAZ,CAAsBF,QAAtB;;MACAR,WAAW,mCACPA,WADO;QAEVM,YAAY,EAAZA;MAFU,EAAX;IAIA;;IAED,IAAI,CAAC,KAAI,CAACK,SAAV,EAAqB;MACpB,KAAI,CAACC,qCAAL,GAA6CZ,WAA7C;MACA;IACA;;IAED,IAAIjB,kBAAJ,EAAwB;MACvB8B,2BAA2B,CAAClC,IAA5B,CAAiC,KAAjC,EAAuC;QACtCqB,WAAW,EAAXA,WADsC;QAEtCc,MAAM,EAAE/B;MAF8B,CAAvC;IAIA,CALD,MAKO,IAAIiB,WAAJ,EAAiB;MACvB,KAAI,CAACe,WAAL,CAAiBf,WAAjB;IACA,CAFM,MAEA;MACNxC,GAAG,CAAC,qBAAD,CAAH;IACA;EACD,CA3MD,CANyB,CAmNzB;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EACA,SAASsC,kBAAT,CAA4BJ,SAA5B,EAAuCsB,SAAvC,EAAkD;IACjD;IACA,IAAItB,SAAJ,EAAe;MACd,IACCE,mBADD,GAGIF,SAHJ,CACCE,mBADD;MAAA,IAECqB,kBAFD,GAGIvB,SAHJ,CAECuB,kBAFD;;MAKA,qBAGI,KAAKC,QAAL,EAHJ;MAAA,IACC/B,WADD,kBACCA,WADD;MAAA,IAECgC,UAFD,kBAECA,UAFD,CANc,CAWd;;;MACA,IAAI,KAAKC,oDAAT,EAA+D;QAC9D,gCAAgBC,MAAM,CAACC,IAAP,CAAY,KAAKF,oDAAjB,CAAhB,kCAAwF;UAAnF,IAAMG,CAAC,mBAAP;UACJpC,WAAW,CAACS,mBAAmB,GAAG4B,MAAM,CAACD,CAAD,CAA7B,CAAX,GAA+C,KAAKH,oDAAL,CAA0DG,CAA1D,CAA/C;QACA;MACD,CAhBa,CAkBd;;;MACA,IAAI,KAAKE,mDAAT,EAA8D;QAC7D,kCAAgBJ,MAAM,CAACC,IAAP,CAAY,KAAKG,mDAAjB,CAAhB,qCAAuF;UAAlF,IAAMF,GAAC,qBAAP;UACJJ,UAAU,CAACvB,mBAAmB,GAAG4B,MAAM,CAACD,GAAD,CAA7B,CAAV,GAA8C,KAAKE,mDAAL,CAAyDF,GAAzD,CAA9C;QACA;MACD;;MAED,IAAI3B,mBAAmB,KAAK,CAA5B,EAA+B;QAC9B;QACA,IAAI,KAAK8B,0BAAT,EAAqC;UACpC,IACC,KAAKA,0BAAL,CAAgCzB,mBAAhC,KAAwDe,SAAS,CAACf,mBAAlE,IACA,KAAKyB,0BAAL,CAAgCxB,kBAAhC,KAAuDc,SAAS,CAACd,kBAFlE,EAGE,CACD;YACA;YACA;UACA,CAPD,MAOO;YACNzC,IAAI,CAAC,2HAAD,CAAJ;YACAA,IAAI,CAAC,8BAAD,EAAiC,KAAKiE,0BAAtC,CAAJ;YACAjE,IAAI,CAAC,YAAD,EAAeuD,SAAf,CAAJ;YACA,KAAKU,0BAAL,GAAkCpC,SAAlC;UACA;QACD;;QACD,OAAO,iBAAP;MACA,CAlBD,MAkBO;QACN,IAAI,KAAKqC,qBAAL,CAA2BC,WAA3B,EAAJ,EAA8C;UAC7C,IAAIZ,SAAS,CAACf,mBAAV,KAAkC,CAAtC,EAAyC;YACxC;YACAzC,GAAG,CAAC,6BAAD,CAAH;YACA,IAAMqE,sBAAsB,GAAG,KAAKF,qBAAL,CAA2BG,yBAA3B,CAAqD;cACnFvD,iBAAiB,EAAEyC,SAAS,CAACzC;YADsD,CAArD,CAA/B;YAGA,KAAKoD,qBAAL,CAA2BvC,KAA3B;;YACA,IAAIyC,sBAAJ,EAA4B;cAC3BrE,GAAG,CAAC,gBAAD,EAAmBqE,sBAAnB,CAAH;cACA,KAAKpB,MAAL,CAAYC,SAAZ,CAAsBmB,sBAAtB;YACA,CAHD,MAGO;cACNrE,GAAG,CAAC,iCAAD,CAAH;YACA,CAZuC,CAaxC;;;YACA,IAAI,KAAKkE,0BAAT,EAAqC;cACpC,IACC,KAAKA,0BAAL,CAAgCzB,mBAAhC,KAAwD,CAAxD,IACA,KAAKyB,0BAAL,CAAgCxB,kBAAhC,KAAuDc,SAAS,CAACd,kBAAV,GAA+BN,mBAFvF,EAGE;gBACD,KAAK8B,0BAAL,GAAkC;kBACjCnD,iBAAiB,EAAE,CADc;kBAEjCwD,gBAAgB,EAAE,KAAKL,0BAAL,CAAgCK,gBAAhC,GAAmDF,sBAFpC;kBAGjC5B,mBAAmB,EAAE,CAHY;kBAIjCC,kBAAkB,EAAEc,SAAS,CAACd;gBAJG,CAAlC;cAMA,CAVD,MAUO;gBACNzC,IAAI,CAAC,4HAAD,CAAJ;gBACAA,IAAI,CAAC,8BAAD,EAAiC,KAAKiE,0BAAtC,CAAJ;gBACAjE,IAAI,CAAC,YAAD,EAAeuD,SAAf,CAAJ;gBACA,KAAKU,0BAAL,GAAkCpC,SAAlC;cACA;YACD;;YACD,OAAO,kBAAP;UACA,CAjCD,MAiCO;YACN7B,IAAI,8CAAqCuD,SAAS,CAACf,mBAA/C,wEAAJ;UACA;QACD;MACD;IACD,CArFgD,CAuFjD;IACA;;;IACA,KAAKyB,0BAAL,GAAkCpC,SAAlC;EACA;;EAED,SAASuB,2BAAT,OAGG;IAAA,IAFFC,MAEE,QAFFA,MAEE;IAAA,IADFd,WACE,QADFA,WACE;;IACF;IACA;IACA;IACA;IACA;IACA,IAAI,KAAKgC,uBAAT,EAAkC;MACjC;MACAhC,WAAW,GAAG,KAAKiC,iBAAL,CAAuB;QAAEjC,WAAW,EAAXA;MAAF,CAAvB,CAAd,CAFiC,CAGjC;;MACA,KAAKkC,mBAAL,CAAyB;QACxBpB,MAAM,EAANA,MADwB;QAExBd,WAAW,EAAXA;MAFwB,CAAzB;IAIA,CARD,MAQO;MACN,KAAKmC,wBAAL,CAA8B;QAC7BrB,MAAM,EAANA,MAD6B;QAE7Bd,WAAW,EAAXA;MAF6B,CAA9B;IAIA;EACD;;EAED,SAAStB,qBAAT,GAAiC;IAChC;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAMI,eAAe,GAAGsD,OAAO,CAAC,KAAKtD,eAAN,CAA/B,CAfgC,CAgBhC;IACA;;IACA,KAAKA,eAAL,GAAuBQ,SAAvB,CAlBgC,CAoBhC;;IACA,IAAMV,gCAAgC,GAAG,KAAKyD,yBAAL,KAAmC/C,SAA5E;;IACA,IAAIV,gCAAJ,EAAsC;MACrCpB,GAAG,CAAC,yBAAD,EAA4B,KAAK6E,yBAAjC,CAAH;IACA,CAxB+B,CAyBhC;;;IACA,KAAKA,yBAAL,GAAiC/C,SAAjC,CA1BgC,CA4BhC;;IACA,KAAKgD,sBAAL,GAA8BhD,SAA9B,CA7BgC,CA+BhC;;IACA,KAAK8B,oDAAL,GAA4D9B,SAA5D,CAhCgC,CAkChC;;IACA,KAAKmC,mDAAL,GAA2DnC,SAA3D,CAnCgC,CAqChC;;IACA,IAAMT,oBAAoB,GAAG,KAAK0D,+CAAlC;IACA,KAAKA,+CAAL,GAAuDjD,SAAvD;IAEA,OAAO;MACNV,gCAAgC,EAAhCA,gCADM;MAENC,oBAAoB,EAApBA,oBAFM;MAGNC,eAAe,EAAfA;IAHM,CAAP;EAKA;AACD"}